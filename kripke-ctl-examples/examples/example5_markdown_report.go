package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/rfielding/kripke-ctl/kripke"
)

// This example generates a Markdown report with embedded Mermaid diagrams

func main() {
	var report strings.Builder

	// Header
	report.WriteString("# Producer-Consumer CTL Verification Report\n\n")
	report.WriteString("Generated by kripke-ctl\n\n")
	report.WriteString("---\n\n")

	// System Description
	report.WriteString("## System Description\n\n")
	report.WriteString("A producer-consumer system with bounded buffer:\n\n")
	report.WriteString("- Producer creates items and sends them to a buffer (capacity: 2)\n")
	report.WriteString("- Consumer receives items from the buffer\n")
	report.WriteString("- When buffer is full, producer must wait\n")
	report.WriteString("- When buffer is empty, consumer must wait\n\n")

	// Build Kripke Graph
	report.WriteString("## State Space\n\n")
	
	g := kripke.NewGraph()

	// States
	s0 := g.AddState("buffer_0", map[string]bool{
		"producer_ready": true,
		"consumer_ready": false,
		"buffer_empty":   true,
		"buffer_size_0":  true,
	})

	g.AddState("buffer_1", map[string]bool{
		"producer_ready": true,
		"consumer_ready": true,
		"buffer_size_1":  true,
	})

	g.AddState("buffer_2", map[string]bool{
		"producer_ready": false,
		"consumer_ready": true,
		"buffer_full":    true,
		"buffer_size_2":  true,
	})

	// Transitions
	g.AddEdge("buffer_0", "buffer_1")
	g.AddEdge("buffer_1", "buffer_2")
	g.AddEdge("buffer_1", "buffer_0")
	g.AddEdge("buffer_2", "buffer_1")

	g.SetInitial("buffer_0")

	// Document states
	report.WriteString(fmt.Sprintf("The system has **%d states**:\n\n", len(g.States())))
	
	for _, sid := range g.States() {
		name := g.NameOf(sid)
		labels := []string{}
		
		if g.HasLabel(sid, "buffer_empty") {
			labels = append(labels, "empty")
		}
		if g.HasLabel(sid, "buffer_full") {
			labels = append(labels, "full")
		}
		if g.HasLabel(sid, "producer_ready") {
			labels = append(labels, "producer can send")
		}
		if g.HasLabel(sid, "consumer_ready") {
			labels = append(labels, "consumer can receive")
		}
		
		report.WriteString(fmt.Sprintf("- **%s**: %s\n", name, strings.Join(labels, ", ")))
	}
	report.WriteString("\n")

	// State Diagram
	report.WriteString("## State Diagram\n\n")
	report.WriteString("```mermaid\n")  // Proper fence
	report.WriteString(generateMermaid(g))
	report.WriteString("```\n\n")  // Closing fence on its own line

	// CTL Properties
	report.WriteString("## CTL Properties Verification\n\n")
	
	properties := []struct {
		name        string
		formula     kripke.Formula
		description string
		explanation string
	}{
		{
			name:        "Safety",
			formula:     kripke.AG(kripke.Not(kripke.Atom("buffer_overflow"))),
			description: "Buffer never overflows",
			explanation: "AG(¬buffer_overflow) - In all reachable states, the buffer is never over capacity",
		},
		{
			name:        "Liveness-Producer",
			formula:     kripke.AG(kripke.EF(kripke.Atom("producer_ready"))),
			description: "Producer can always eventually send",
			explanation: "AG(EF(producer_ready)) - From any state, there exists a path where producer can send",
		},
		{
			name:        "Liveness-Consumer",
			formula:     kripke.AG(kripke.EF(kripke.Atom("consumer_ready"))),
			description: "Consumer can always eventually receive",
			explanation: "AG(EF(consumer_ready)) - From any state, there exists a path where consumer can receive",
		},
		{
			name:        "No-Deadlock",
			formula:     kripke.AG(kripke.Or(kripke.Atom("producer_ready"), kripke.Atom("consumer_ready"))),
			description: "System never deadlocks",
			explanation: "AG(producer_ready ∨ consumer_ready) - In every state, at least one actor can make progress",
		},
		{
			name:        "Reachability-Full",
			formula:     kripke.EF(kripke.Atom("buffer_full")),
			description: "Buffer can become full",
			explanation: "EF(buffer_full) - There exists a path where the buffer reaches capacity",
		},
		{
			name:        "Reachability-Empty",
			formula:     kripke.EF(kripke.Atom("buffer_empty")),
			description: "Buffer can become empty",
			explanation: "EF(buffer_empty) - There exists a path where the buffer becomes empty",
		},
	}

	initialStates := kripke.NewStateSet()
	initialStates.Add(s0)

	report.WriteString("| Property | Result | Description | Formula |\n")
	report.WriteString("|----------|--------|-------------|----------|\n")

	for _, p := range properties {
		satisfying := p.formula.Sat(g)

		allInitialsSatisfy := true
		for id := range initialStates {
			if !satisfying.Contains(id) {
				allInitialsSatisfy = false
				break
			}
		}

		status := "❌ FAIL"
		if allInitialsSatisfy {
			status = "✅ PASS"
		}

		report.WriteString(fmt.Sprintf("| %s | %s | %s | `%s` |\n",
			p.name, status, p.description, p.explanation))
	}
	report.WriteString("\n")

	// Detailed Results
	report.WriteString("## Detailed Results\n\n")
	
	for _, p := range properties {
		satisfying := p.formula.Sat(g)

		allInitialsSatisfy := true
		for id := range initialStates {
			if !satisfying.Contains(id) {
				allInitialsSatisfy = false
				break
			}
		}

		status := "❌ FAIL"
		statusEmoji := "❌"
		if allInitialsSatisfy {
			status = "✅ PASS"
			statusEmoji = "✅"
		}

		report.WriteString(fmt.Sprintf("### %s %s: %s\n\n", statusEmoji, p.name, p.description))
		report.WriteString(fmt.Sprintf("**Formula**: `%s`\n\n", p.explanation))
		report.WriteString(fmt.Sprintf("**Result**: %s\n\n", status))
		
		if len(satisfying) > 0 && len(satisfying) <= 10 {
			report.WriteString("**Satisfying states**: ")
			states := []string{}
			for sid := range satisfying {
				states = append(states, g.NameOf(sid))
			}
			report.WriteString(strings.Join(states, ", "))
			report.WriteString("\n\n")
		}
	}

	// Transition Graph
	report.WriteString("## Transition Graph\n\n")
	report.WriteString("```mermaid\n")
	report.WriteString("graph LR\n")
	
	for _, sid := range g.States() {
		name := g.NameOf(sid)
		for _, tid := range g.Succ(sid) {
			target := g.NameOf(tid)
			action := ""
			if target > name {
				action = "|produce|"
			} else {
				action = "|consume|"
			}
			report.WriteString(fmt.Sprintf("    %s -->%s %s\n", name, action, target))
		}
	}
	report.WriteString("```\n\n")

	// Conclusion
	report.WriteString("## Conclusion\n\n")
	report.WriteString("The producer-consumer system with bounded buffer (capacity 2) has been verified.\n\n")
	
	passCount := 0
	for _, p := range properties {
		satisfying := p.formula.Sat(g)
		allSatisfy := true
		for id := range initialStates {
			if !satisfying.Contains(id) {
				allSatisfy = false
				break
			}
		}
		if allSatisfy {
			passCount++
		}
	}
	
	report.WriteString(fmt.Sprintf("**Summary**: %d/%d properties verified successfully.\n\n", passCount, len(properties)))
	
	// Key findings
	report.WriteString("**Key Findings**:\n\n")
	report.WriteString("- The system is **deadlock-free** - at least one actor can always make progress\n")
	report.WriteString("- Both producer and consumer can always eventually take actions (**liveness**)\n")
	report.WriteString("- The buffer never overflows (**safety**)\n")
	report.WriteString("- All reachable states are accessible from the initial state\n\n")

	// Write to file
	filename := "producer-consumer-report.md"
	err := os.WriteFile(filename, []byte(report.String()), 0644)
	if err != nil {
		fmt.Printf("Error writing file: %v\n", err)
		return
	}

	fmt.Printf("✅ Report generated: %s\n", filename)
	fmt.Printf("   States: %d\n", len(g.States()))
	fmt.Printf("   Properties verified: %d/%d passed\n", passCount, len(properties))
	fmt.Println("\nView the report in any Markdown viewer or copy to GitHub/GitLab for rendering.")
}

func generateMermaid(g *kripke.Graph) string {
	var sb strings.Builder
	sb.WriteString("stateDiagram-v2\n")
	
	// Initial state
	if len(g.InitialStates()) > 0 {
		initName := g.NameOf(g.InitialStates()[0])
		sb.WriteString(fmt.Sprintf("    [*] --> %s\n", initName))
	}
	sb.WriteString("\n")

	// Transitions with labels
	for _, sid := range g.States() {
		name := g.NameOf(sid)
		for _, tid := range g.Succ(sid) {
			target := g.NameOf(tid)
			
			action := ""
			if target > name {
				action = ": produce"
			} else {
				action = ": consume"
			}
			
			sb.WriteString(fmt.Sprintf("    %s --> %s%s\n", name, target, action))
		}
	}

	sb.WriteString("\n")

	// State descriptions
	for _, sid := range g.States() {
		name := g.NameOf(sid)
		desc := name
		
		if g.HasLabel(sid, "buffer_empty") {
			desc = "Empty Buffer (P:ready C:blocked)"
		} else if g.HasLabel(sid, "buffer_full") {
			desc = "Full Buffer (P:blocked C:ready)"
		} else {
			desc = "Partial Buffer (P:ready C:ready)"
		}
		
		sb.WriteString(fmt.Sprintf("    %s: %s\n", name, desc))
	}

	return sb.String()
}
