ENGINE SEMANTICS

This document explains how the engine constructs the Kripke structure
that CTL formulas are evaluated against.

You should read ctl.md first. That document defines:

  - the Kripke structure M = (S, R, L)
  - the CTL operators EF / AF / EG / AG
  - how “must”, “may”, “always”, “eventually”, “required”, and “allowed”
    are interpreted as CTL formulas

This document explains how the engine produces S and R.

-----------------------------------------------------------------------

1. BIG PICTURE

The engine is the operational semantics of the system.

  - A state in S is one concrete World value.
  - A transition in R is one atomic Step that transforms a World.
  - A path is a sequence of Worlds produced by repeatedly applying Steps.

CTL formulas are evaluated over the graph generated by the engine.
The engine itself does not know or care about CTL; it only enumerates
what can happen.

-----------------------------------------------------------------------

2. WORLD (STATE)

World represents a single state in the Kripke structure.

A World is a snapshot of:

  - all processes (actors)
  - all channels and their contents
  - any global variables (counters, flags, configuration)
  - any additional data needed to determine enabled Steps

All information relevant to model checking must live in World.

The engine assumes:

  - World is pure data for semantic purposes
  - All state changes occur by producing a new World
  - There are no hidden mutable globals that affect behavior

If something influences future behavior, it must be encoded in World.

-----------------------------------------------------------------------

3. PROCESS (ACTOR STATE)

A Process represents one actor inside the system.

A Process may contain:

  - local variables
  - program counter or mode
  - channel endpoints
  - actor-specific state

Conceptually, World contains a mapping:

  ProcessID -> ProcessState

A Process does not execute autonomously.
Instead, it proposes potential Steps that may be taken when enabled.

-----------------------------------------------------------------------

4. CHANNELS

Channels are modeled explicitly as bounded queues stored in World.

Each channel has:

  - an identifier
  - a capacity (possibly unbounded)
  - an ordered FIFO sequence of messages

Send semantics:

  - append to the queue if capacity allows

Receive semantics:

  - remove from the front of the queue if non-empty

Because channels are part of World, CTL formulas can talk about them:

  - QueueEmpty
  - QueueSizeLeqN
  - NoMessageLoss
  - EventuallyDequeued

These are encoded as predicates over World.

-----------------------------------------------------------------------

5. STEP (TRANSITION)

A Step is the smallest atomic unit of change.

Conceptually:

  Step : World -> World'

A Step may:

  - read from one or more channels
  - write to channels
  - update process-local state
  - update global state
  - emit an event (optionally)

Key invariants:

  - A Step is deterministic given its input World
  - Nondeterminism arises from which Step is chosen, not inside Step
  - Steps are only applicable when their preconditions hold

In the Kripke structure:

  - S is the set of all reachable Worlds
  - (W, W') is in R iff there exists a Step with Step(W) = W'

-----------------------------------------------------------------------

6. ENABLED STEPS AND SCHEDULER

At any given World, there may be many enabled Steps:

  - multiple processes can act
  - multiple channels may be readable or writable
  - timers or events may fire

The scheduler chooses which enabled Step to execute next.

Conceptually:

  Enabled(World) -> {Step1, Step2, ...}
  Scheduler(World, EnabledSet) -> Step

Different schedulers correspond to different exploration strategies:

  - depth-first
  - breadth-first
  - bounded
  - randomized
  - fairness-aware (future work)

For CTL semantics, R contains all transitions th
