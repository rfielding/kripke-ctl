<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>kripke-ctl Docs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Hardcoded dark mode -->
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: #111;
      color: #ddd;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    #sidebar {
      width: 260px;
      background: #000;
      color: #ccc;
      border-right: 1px solid #333;
      padding: 0.75rem 0.5rem;
      display: flex;
      flex-direction: column;
    }

    #sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.6rem 0.4rem;
      color: #fff;
    }

    #sidebar h2 {
      font-size: 0.9rem;
      margin: 0.8rem 0 0.3rem 0.4rem;
      color: #aaa;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    #sidebar a {
      color: #9cf;
      text-decoration: none;
      display: block;
      padding: 0.35rem 0.7rem;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    #sidebar a:hover {
      background: #222;
    }

    #sidebar a.active {
      background: #1b2733;
      color: #e0f0ff;
    }

    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    #content-container {
      flex: 1;
      overflow-y: auto;
      padding: 1rem 2rem;
      background: #111;
      color: #ddd;
    }

    #content-container h1,
    #content-container h2,
    #content-container h3 {
      color: #fff;
    }

    #content-container pre {
      background: #1b1b1b;
      padding: 0.75rem 1rem;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.9rem;
    }

    #content-container code {
      background: #1b1b1b;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 0.9rem;
    }

    #content-container pre code {
      padding: 0;
      background: transparent;
    }

    a {
      color: #9cf;
    }

    hr {
      border: 0;
      border-top: 1px solid #333;
      margin: 1.5rem 0;
    }

    /* Assistant panel */

    #assistant {
      background: #000;
      padding: 1rem 1.5rem;
      border-top: 1px solid #333;
      box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.5);
    }

    #assistant h2 {
      margin-top: 0;
      font-size: 1rem;
      color: #fff;
    }

    #assistant label {
      display: block;
      font-size: 0.85rem;
      color: #aaa;
      margin-bottom: 0.25rem;
    }

    #assistant textarea {
      width: 100%;
      min-height: 70px;
      margin-top: 0.25rem;
      background: #222;
      color: #eee;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 0.5rem;
      resize: vertical;
      font-family: inherit;
      font-size: 0.9rem;
    }

    #assistant button {
      margin-top: 0.6rem;
      background: #222;
      color: #ccc;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 0.4rem 0.9rem;
      font-size: 0.9rem;
      cursor: pointer;
    }

    #assistant button:hover {
      background: #333;
    }

    #assistant-output {
      margin-top: 0.8rem;
      font-size: 0.9rem;
      color: #ddd;
    }

    #assistant-output pre.error {
      background: #200;
      color: #ff9b9b;
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      white-space: pre-wrap;
    }

    #assistant-output .mermaid {
      background: #111;
      border-radius: 4px;
      padding: 0.5rem;
      margin-top: 0.5rem;
    }

    /* Mermaid diagrams inside docs */
    .mermaid {
      background: #111;
      border-radius: 4px;
      padding: 0.5rem;
      margin: 1rem 0;
    }

    @media (max-width: 800px) {
      body {
        flex-direction: column;
      }
      #sidebar {
        width: 100%;
        flex-direction: row;
        overflow-x: auto;
        border-right: none;
        border-bottom: 1px solid #333;
      }
      #sidebar h1,
      #sidebar h2 {
        display: none;
      }
      #sidebar a {
        white-space: nowrap;
        padding: 0.35rem 0.5rem;
      }
      #main {
        height: calc(100vh - 48px);
      }
    }
  </style>

  <!-- marked.js for Markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- mermaid.js for diagrams -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({
      startOnLoad: false,
      theme: "dark",
    });
  </script>
</head>
<body>
  <div id="sidebar">
    <h1>kripke-ctl</h1>
    <h2>Docs</h2>
    <a href="#" data-doc="overview.md" class="active">Overview</a>
    <a href="#" data-doc="tutorial.md">Tutorial</a>
    <a href="#" data-doc="business.md">Business models</a>
    <a href="#" data-doc="engine.md">Engine</a>
    <a href="#" data-doc="ctl.md">CTL</a>
    <a href="#" data-doc="examples.md">Examples</a>
    <a href="#" data-doc="diagrams.md">Diagrams</a>
    <a href="#" data-doc="api.md">API & CLI</a>
  </div>

  <div id="main">
    <div id="content-container">
      <div id="content">Loading…</div>
    </div>

    <div id="assistant">
      <h2>kripke-ctl assistant</h2>
      <label for="assistant-input">
        Describe what you want: a model, a diagram, a CTL property, etc.
        The assistant decides whether to emit Mermaid, Markdown with images, or plain text.
      </label>
      <textarea
        id="assistant-input"
        placeholder="Example: Model an M/M/1 queue with arrival rate λ, service rate μ, and a hard cap of 10 items in the system. Emit a Mermaid state diagram, or any diagrams you think are useful."
      ></textarea>
      <br />
      <button id="assistant-send">Ask kripke-ctl</button>

      <div id="assistant-output"></div>
    </div>
  </div>

  <script>
    // --- Docs navigation (Markdown + Mermaid) ------------------------------

    const contentEl = document.getElementById("content");
    const navLinks = Array.from(document.querySelectorAll("#sidebar a[data-doc]"));

    async function loadDoc(name) {
      try {
        const resp = await fetch(`/docs/${name}`);
        if (!resp.ok) {
          contentEl.innerHTML =
            `<p>Failed to load <code>${name}</code>: ${resp.status}</p>`;
          return;
        }
        const md = await resp.text();
        const html = marked.parse(md);
        contentEl.innerHTML = html;

        // Turn ```mermaid``` code blocks into live diagrams
        const mermaidBlocks = contentEl.querySelectorAll("code.language-mermaid");
        if (mermaidBlocks.length > 0) {
          mermaidBlocks.forEach((codeBlock) => {
            const pre = codeBlock.parentElement;
            const div = document.createElement("div");
            div.className = "mermaid";
            div.textContent = codeBlock.textContent;
            pre.replaceWith(div);
          });
          mermaid.init(undefined, contentEl.querySelectorAll(".mermaid"));
        }
      } catch (err) {
        contentEl.innerHTML =
          `<p>Error loading <code>${name}</code>: ${String(err)}</p>`;
      }
    }

    navLinks.forEach((link) => {
      link.addEventListener("click", (e) => {
        e.preventDefault();
        const doc = link.getAttribute("data-doc");
        navLinks.forEach((l) => l.classList.remove("active"));
        link.classList.add("active");
        loadDoc(doc);
      });
    });

    // Load default doc
    loadDoc("overview.md");

    // --- Assistant: generic /api/chat using Responses API ------------------

    const assistantInput = document.getElementById("assistant-input");
    const assistantSend = document.getElementById("assistant-send");
    const assistantOutput = document.getElementById("assistant-output");

    function setAssistantStatus(msg, isError = false) {
      assistantOutput.innerHTML = "";
      const pre = document.createElement("pre");
      pre.textContent = msg;
      if (isError) pre.className = "error";
      assistantOutput.appendChild(pre);
    }

    function extractTextFromResponses(data) {
      // Expecting Responses API shape:
      // data.output[*].content[*].text
      if (!data || !Array.isArray(data.output)) return "";
      let buf = "";
      for (const out of data.output) {
        const content = out.content || [];
        for (const item of content) {
          if (item.type === "output_text" && typeof item.text === "string") {
            buf += item.text;
          }
        }
      }
      return buf.trim();
    }

    function renderAssistantMarkdown(mdText) {
      assistantOutput.innerHTML = "";

      // Render markdown to HTML
      const html = marked.parse(mdText);
      const container = document.createElement("div");
      container.innerHTML = html;
      assistantOutput.appendChild(container);

      // Convert ```mermaid``` blocks inside the assistant answer
      const mermaidBlocks = assistantOutput.querySelectorAll("code.language-mermaid");
      if (mermaidBlocks.length > 0) {
        mermaidBlocks.forEach((codeBlock) => {
          const pre = codeBlock.parentElement;
          const div = document.createElement("div");
          div.className = "mermaid";
          div.textContent = codeBlock.textContent;
          pre.replaceWith(div);
        });
        mermaid.init(undefined, assistantOutput.querySelectorAll(".mermaid"));
      }
    }

    async function callAssistant() {
      const prompt = assistantInput.value.trim();
      if (!prompt) {
        setAssistantStatus("Please type a question or description first.", true);
        return;
      }

      assistantSend.disabled = true;
      assistantSend.textContent = "Thinking…";
      setAssistantStatus("Calling /api/chat…");

      try {
        const resp = await fetch("/api/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ prompt: prompt }),
        });

        if (!resp.ok) {
          const text = await resp.text();
          setAssistantStatus(
            `Error from server: ${resp.status}\n\n${text}`,
            true
          );
          return;
        }

        const data = await resp.json();
        // If your server eventually wants to special-case markdown, you can.
        const text = extractTextFromResponses(data) || "";
        if (!text) {
          setAssistantStatus("Got empty response from model.", true);
          return;
        }

        renderAssistantMarkdown(text);
      } catch (err) {
        setAssistantStatus("Error calling /api/chat: " + String(err), true);
      } finally {
        assistantSend.disabled = false;
        assistantSend.textContent = "Ask kripke-ctl";
      }
    }

    assistantSend.addEventListener("click", (e) => {
      e.preventDefault();
      callAssistant();
    });

    assistantInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        callAssistant();
      }
    });
  </script>
</body>
</html>

